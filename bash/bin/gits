#!/bin/bash
# {{{ Colors and Icons
GREEN="\e[32m"
YELLOW="\e[33m"
RED="\e[31m"
BLUE="\e[34m"
RESET="\e[0m"

ICON_UPTODATE="✅"
ICON_PULLING="🔄"
ICON_STASH="💾"
ICON_ERROR="❌"
ICON_FOLDER="📁"
ICON_TOTAL="📦"
ICON_TIME="⏱️"

# Compact mode toggle
COMPACT=true

# Flags
FLAG_CLEAN=false
FLAG_UTF16=false
FLAG_LIST_STASH=false
FLAG_PULL=false
FLAG_HELP=false

# Summary counters
count_total=0
count_uptodate=0
count_pull=0
count_diverged=0
count_nogit=0
count_stash=0

# Timer start
start_time=$(date +%s.%N)

# -------------------------------------------------------------------------- }}}
# {{{ List directory names in current folder

lsd() { ls -d */ 2>/dev/null | tr -d '/'; }

# -------------------------------------------------------------------------- }}}
# {{{ Get repo provider folder
repo() {
  local repoLocation="$1"

  case "$repoLocation" in
    bb)    echo "bb" ;;
    git)   echo "git" ;;
    vim)   echo "git/vim/bundle" ;;
    soup)  echo "soup" ;;
    work)  echo "gitea" ;;
    *)     echo "git" ;;
  esac
}

# -------------------------------------------------------------------------- }}}
# {{{ Remove untracked files

removeUntracked() {
  git clean -fd
}

# -------------------------------------------------------------------------- }}}
# {{{ Convert UTF16 FE files to UTF8

convertUtf16ToUtf8() {
  local files
  files=$(find . -type f -exec file {} \; | grep "UTF-16" | cut -d: -f1)
  for f in $files; do
    iconv -f UTF-16 -t UTF-8 "$f" -o "$f.converted" && mv "$f.converted" "$f"
    echo -e "${YELLOW}Converted $f to UTF-8${RESET}"
  done
}

# -------------------------------------------------------------------------- }}}
# {{{ List repositories with stashes

listStashedRepos() {
  if [[ -n $(git stash list) ]]; then
    local repoName
    repoName=$(basename "$(pwd)")
    echo -e "${YELLOW}${ICON_STASH} ${repoName} has stashed items${RESET}"
    ((count_stash++))
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Pull latest changes

refreshRepo() {
  local repoLocation="$1"

  ((count_total++))

  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    local repoName
    repoName=$(basename "$(pwd)")
    echo -e "${RED}${ICON_FOLDER} Directory ${repoName} is not a git repository${RESET}"
    ((count_nogit++))
    return
  fi

  local repoName
  repoName=$(basename "$(pwd)")

  if $FLAG_CLEAN; then
    removeUntracked
    echo -e "${BLUE}Cleaned untracked files in ${repoName}${RESET}"
    return
  fi

  if $FLAG_UTF16; then
    convertUtf16ToUtf8
    return
  fi

  if $FLAG_LIST_STASH; then
    listStashedRepos
    return
  fi

  if $FLAG_PULL; then
    # Stash any local changes
    if [[ -n $(git status --porcelain) ]]; then
      git stash push -u -m "Auto-stash before pull" &>/dev/null
      $COMPACT || echo -e "${YELLOW}${ICON_STASH} Stashed changes in ${repoName}${RESET}"
    fi

    # Fetch and check status
    git fetch &>/dev/null

    local localHash remoteHash baseHash
    localHash=$(git rev-parse @)
    remoteHash=$(git rev-parse @{u} 2>/dev/null || true)
    baseHash=$(git merge-base @ @{u} 2>/dev/null || true)

    if [[ -z "$remoteHash" ]]; then
      echo -e "${RED}${ICON_ERROR} ${repoName} has no upstream${RESET}"
      ((count_nogit++))
      return
    fi

    if [[ "$localHash" == "$remoteHash" ]]; then
      echo -e "${GREEN}${ICON_UPTODATE} ${repoName}${RESET}"
      ((count_uptodate++))
    elif [[ "$localHash" == "$baseHash" ]]; then
      echo -e "${BLUE}${ICON_PULLING} ${repoName}${RESET}"
      git pull --ff-only
      ((count_pull++))
    else
      echo -e "${RED}${ICON_ERROR} ${repoName} diverged: manual merge needed${RESET}"
      ((count_diverged++))
    fi
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Show Help

showHelp() {
  echo "Usage: gits <repoLocation> [options]"
  echo "Options:"
  echo "  -p     Pull latest changes"
  echo "  -x     Remove untracked files"
  echo "  -U     Convert UTF-16 files to UTF-8"
  echo "  -s     List repositories with stash entries"
  echo "  -h     Show this help message"
}

# -------------------------------------------------------------------------- }}}
# {{{ Scan git repositories

gits() {
  local repoLocation="$1"
  shift

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -p) FLAG_PULL=true ;;
      -x) FLAG_CLEAN=true ;;
      -U) FLAG_UTF16=true ;;
      -s) FLAG_LIST_STASH=true ;;
      -h) FLAG_HELP=true ;;
    esac
    shift
  done

  if $FLAG_HELP; then
    showHelp
    exit 0
  fi

  # If no action flags are set, default to -p
  if ! $FLAG_PULL && ! $FLAG_CLEAN && ! $FLAG_UTF16 && ! $FLAG_LIST_STASH; then
    FLAG_PULL=true
  fi

  # Save current directory
  local dir=$(pwd)

  # Move to repoLocation root
  local repoRoot
  repoRoot=$(repo "$repoLocation")

  if [[ ! -d "$HOME/$repoRoot" ]]; then
    echo -e "${RED}${ICON_ERROR} Directory $HOME/$repoRoot does not exist.${RESET}"
    exit 1
  fi

  cd "$HOME/$repoRoot" || exit

  for i in $(lsd); do
    local d="$HOME/$repoRoot/$i"

    pushd "$d" >/dev/null || continue
    refreshRepo "$repoLocation"
    popd >/dev/null || true
  done

  # Restore current directory
  cd "$dir" || exit
}

# -------------------------------------------------------------------------- }}}
# {{{ Kick start

if [[ "$1" == "-h" || "$2" == "-h" ]]; then
  showHelp
  exit 0
fi

gits "$@"
showSummary

# -------------------------------------------------------------------------- }}}
