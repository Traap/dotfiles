#!/bin/bash
# {{{ Colors and Icons
GREEN="\e[32m"
YELLOW="\e[33m"
RED="\e[31m"
BLUE="\e[34m"
RESET="\e[0m"

ICON_UPTODATE="✅"
ICON_PULLING="🔄"
ICON_STASH="💾"
ICON_ERROR="❌"
ICON_FOLDER="📁"

# Compact mode toggle
COMPACT=true

# Summary counters
count_total=0
count_uptodate=0
count_pull=0
count_diverged=0
count_nogit=0

# Timer start
start_time=$(date +%s)

# -------------------------------------------------------------------------- }}}
# {{{ List directory names in current folder

lsd() { ls -d */ 2>/dev/null | tr -d '/'; }

# -------------------------------------------------------------------------- }}}
# {{{ Get repo provider folder
repo() {
  local repoLocation="$1"

  case "$repoLocation" in
    bb)    echo "bb" ;;
    git)   echo "git" ;;
    vim)   echo "git/vim/bundle" ;;
    soup)  echo "soup" ;;
    work)  echo "gitea" ;;
    *)     echo "git" ;;
  esac
}

# -------------------------------------------------------------------------- }}}
# {{{ Pull latest changes

refreshRepo() {
  local repoLocation="$1"

  ((count_total++))

  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    local repoName
    repoName=$(basename "$(pwd)")
    echo -e "${RED}${ICON_FOLDER} Directory ${repoName} is not a git repository${RESET}"
    ((count_nogit++))
    return
  fi

  local repoName
  repoName=$(basename "$(pwd)")

  # Stash any local changes
  if [[ -n $(git status --porcelain) ]]; then
    git stash push -u -m "Auto-stash before pull" &>/dev/null
    $COMPACT || echo -e "${YELLOW}${ICON_STASH} Stashed changes in ${repoName}${RESET}"
  fi

  # Fetch and check status
  git fetch &>/dev/null

  local localHash remoteHash baseHash
  localHash=$(git rev-parse @)
  remoteHash=$(git rev-parse @{u} 2>/dev/null || true)
  baseHash=$(git merge-base @ @{u} 2>/dev/null || true)

  if [[ -z "$remoteHash" ]]; then
    echo -e "${RED}${ICON_ERROR} ${repoName} has no upstream${RESET}"
    ((count_nogit++))
    return
  fi

  if [[ "$localHash" == "$remoteHash" ]]; then
    echo -e "${GREEN}${ICON_UPTODATE} ${repoName}${RESET}"
    ((count_uptodate++))
  elif [[ "$localHash" == "$baseHash" ]]; then
    echo -e "${BLUE}${ICON_PULLING} ${repoName}${RESET}"
    git pull --ff-only
    ((count_pull++))
  else
    echo -e "${RED}${ICON_ERROR} ${repoName} diverged: manual merge needed${RESET}"
    ((count_diverged++))
  fi
}

# -------------------------------------------------------------------------- }}}
# {{{ Scan git repositories

gits() {
  local repoLocation="$1"

  # Save current directory
  local dir=$(pwd)

  # Move to repoLocation root
  local repoRoot
  repoRoot=$(repo "$repoLocation")
  cd "$HOME/$repoRoot" || exit

  for i in $(lsd); do
    local d="$HOME/$repoRoot/$i"

    pushd "$d" >/dev/null || continue
    refreshRepo "$repoLocation"
    popd >/dev/null || true
  done

  # Restore current directory
  cd "$dir" || exit
}

# -------------------------------------------------------------------------- }}}
# {{{ Show Summary

showSummary() {
  end_time=$(date +%s)
  elapsed=$((end_time - start_time))

  echo -e "\n----- Summary -----"
  echo -e "Total checked : $count_total"
  echo -e "Up-to-date    : $count_uptodate"
  echo -e "Pulled        : $count_pull"
  echo -e "Diverged      : $count_diverged"
  echo -e "Not a repo    : $count_nogit"
  echo -e "Elapsed time  : ${elapsed}s"
  echo -e "-------------------"
}

# -------------------------------------------------------------------------- }}}
# {{{ Kick start

gits "$@"
showSummary

# -------------------------------------------------------------------------- }}}
